-- Drop existing tables that are no longer needed
DROP TABLE IF EXISTS payment_transactions CASCADE;
DROP TABLE IF EXISTS document_requests CASCADE;

-- Create ticket types enum
CREATE TYPE public.ticket_type AS ENUM ('physical', 'electronic', 'premium');

-- Create ticket status enum
CREATE TYPE public.ticket_status AS ENUM ('available', 'sold', 'used', 'expired');

-- Create transaction type enum
CREATE TYPE public.transaction_type AS ENUM ('purchase', 'win', 'refund');

-- Table for ticket pricing configuration
CREATE TABLE public.ticket_prices (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  ticket_type ticket_type NOT NULL UNIQUE,
  price numeric NOT NULL DEFAULT 0,
  premium_multiplier numeric DEFAULT 1.0,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now()
);

-- Insert default prices
INSERT INTO public.ticket_prices (ticket_type, price, premium_multiplier) VALUES
  ('physical', 500, 1.0),
  ('electronic', 300, 1.0),
  ('premium', 2000, 1.5);

-- Table for physical ticket codes (pre-generated by admin)
CREATE TABLE public.physical_tickets (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  ticket_code text NOT NULL UNIQUE,
  is_winner boolean NOT NULL DEFAULT false,
  prize_amount numeric DEFAULT 0,
  status ticket_status NOT NULL DEFAULT 'available',
  purchased_by uuid REFERENCES auth.users(id),
  used_at timestamp with time zone,
  created_at timestamp with time zone NOT NULL DEFAULT now()
);

-- Table for electronic tickets
CREATE TABLE public.electronic_tickets (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  ticket_type ticket_type NOT NULL,
  user_id uuid REFERENCES auth.users(id) NOT NULL,
  is_winner boolean NOT NULL DEFAULT false,
  prize_amount numeric DEFAULT 0,
  status ticket_status NOT NULL DEFAULT 'sold',
  revealed_at timestamp with time zone,
  created_at timestamp with time zone NOT NULL DEFAULT now()
);

-- Table for user wallet/balance
CREATE TABLE public.user_wallets (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users(id) NOT NULL UNIQUE,
  balance numeric NOT NULL DEFAULT 0,
  total_won numeric NOT NULL DEFAULT 0,
  total_spent numeric NOT NULL DEFAULT 0,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now()
);

-- Table for all transactions
CREATE TABLE public.ticket_transactions (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users(id) NOT NULL,
  transaction_type transaction_type NOT NULL,
  amount numeric NOT NULL,
  ticket_type ticket_type,
  physical_ticket_id uuid REFERENCES public.physical_tickets(id),
  electronic_ticket_id uuid REFERENCES public.electronic_tickets(id),
  description text,
  created_at timestamp with time zone NOT NULL DEFAULT now()
);

-- Enable RLS on all tables
ALTER TABLE public.ticket_prices ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.physical_tickets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.electronic_tickets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_wallets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ticket_transactions ENABLE ROW LEVEL SECURITY;

-- RLS Policies for ticket_prices (public read, admin write)
CREATE POLICY "Anyone can view ticket prices"
ON public.ticket_prices FOR SELECT
USING (true);

CREATE POLICY "Admins can manage ticket prices"
ON public.ticket_prices FOR ALL
USING (public.is_admin(auth.uid()));

-- RLS Policies for physical_tickets
CREATE POLICY "Admins can manage physical tickets"
ON public.physical_tickets FOR ALL
USING (public.is_admin(auth.uid()));

CREATE POLICY "Users can view their purchased physical tickets"
ON public.physical_tickets FOR SELECT
USING (purchased_by = auth.uid());

-- RLS Policies for electronic_tickets
CREATE POLICY "Users can view their own electronic tickets"
ON public.electronic_tickets FOR SELECT
USING (user_id = auth.uid());

CREATE POLICY "Users can insert their own electronic tickets"
ON public.electronic_tickets FOR INSERT
WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update their own electronic tickets"
ON public.electronic_tickets FOR UPDATE
USING (user_id = auth.uid());

CREATE POLICY "Admins can manage all electronic tickets"
ON public.electronic_tickets FOR ALL
USING (public.is_admin(auth.uid()));

-- RLS Policies for user_wallets
CREATE POLICY "Users can view their own wallet"
ON public.user_wallets FOR SELECT
USING (user_id = auth.uid());

CREATE POLICY "Users can update their own wallet"
ON public.user_wallets FOR UPDATE
USING (user_id = auth.uid());

CREATE POLICY "Users can insert their own wallet"
ON public.user_wallets FOR INSERT
WITH CHECK (user_id = auth.uid());

CREATE POLICY "Admins can view all wallets"
ON public.user_wallets FOR SELECT
USING (public.is_admin(auth.uid()));

-- RLS Policies for ticket_transactions
CREATE POLICY "Users can view their own transactions"
ON public.ticket_transactions FOR SELECT
USING (user_id = auth.uid());

CREATE POLICY "Users can insert their own transactions"
ON public.ticket_transactions FOR INSERT
WITH CHECK (user_id = auth.uid());

CREATE POLICY "Admins can view all transactions"
ON public.ticket_transactions FOR SELECT
USING (public.is_admin(auth.uid()));

-- Function to create wallet on user signup
CREATE OR REPLACE FUNCTION public.handle_new_user_wallet()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
BEGIN
  INSERT INTO public.user_wallets (user_id, balance)
  VALUES (NEW.id, 0)
  ON CONFLICT (user_id) DO NOTHING;
  RETURN NEW;
END;
$$;

-- Trigger to create wallet on new user
CREATE TRIGGER on_auth_user_created_wallet
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user_wallet();

-- Triggers for updated_at
CREATE TRIGGER update_ticket_prices_updated_at
  BEFORE UPDATE ON public.ticket_prices
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_user_wallets_updated_at
  BEFORE UPDATE ON public.user_wallets
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();